#pragma rtGlobals=3		// Use modern global access method and strict wave access.

function OS_BasicAveraging()

// 1 // check for Parameter Table
if (waveexists($"OS_Parameters")==0)
	print "Warning: OS_Parameters wave not yet generated - doing that now..."
	OS_ParameterTable()
	DoUpdate
endif
wave OS_Parameters
// 2 //  check for Detrended Data stack
variable Channel = OS_Parameters[%Data_Channel]
if (waveexists($"wDataCh"+Num2Str(Channel)+"_detrended")==0)
	print "Warning: wDataCh"+Num2Str(Channel)+"_detrended wave not yet generated - doing that now..."
	OS_DetrendStack()
endif
// 3 //  check for ROI_Mask
if (waveexists($"ROIs")==0)
	print "Warning: ROIs wave not yet generated - doing that now (using correlation algorithm)..."
	OS_AutoRoiByCorr()
	DoUpdate
endif
// 4 //  check if Traces and Triggers are there
if (waveexists($"Triggertimes")==0)
	print "Warning: Traces and Trigger waves not yet generated - doing that now..."
	OS_TracesAndTriggers()
	DoUpdate
endif

// flags from "OS_Parameters"
variable Display_averages = OS_Parameters[%Display_Stuff]
variable use_znorm = OS_Parameters[%Use_Znorm]
variable LineDuration = OS_Parameters[%LineDuration]
variable Triggermode = OS_Parameters[%Trigger_Mode]
variable Ignore1stXseconds = OS_Parameters[%Ignore1stXseconds]
variable IgnoreLastXseconds = OS_Parameters[%IgnoreLastXseconds]
variable AverageStack_make = OS_Parameters[%AverageStack_make]
variable brightness_cutoff = OS_Parameters[%Brightness_cut_8bit]
variable X_cut = OS_Parameters[%LightArtifact_cut]


// data handling
string input_name = "wDataCh"+Num2Str(Channel)+"_detrended"
string traces_name = "Traces"+Num2Str(Channel)+"_raw"
if (use_znorm==1)
	traces_name = "Traces"+Num2Str(Channel)+"_znorm"
endif
string tracetimes_name = "Tracetimes"+Num2Str(Channel)
duplicate /o $input_name InputStack
duplicate /o $traces_name InputTraces
duplicate /o $tracetimes_name InputTraceTimes

wave Triggertimes
variable nF = DimSize(InputTraces,0)
variable nRois = DimSize(InputTraces,1)
variable nX = DimSize(InputStack,0)
variable nY = DimSize(InputStack,1)

wave StimArtifact // generated by "Traces and Triggers"

string output_name1 = "Snippets"+Num2Str(Channel)
string output_name2 = "Averages"+Num2Str(Channel)
string output_name3 = "AverageStack"+Num2Str(Channel)
string output_name4 = "SnippetsTimes"+Num2Str(Channel) // andre addition 2016 04 13
string output_name5 = "AverageStimArtifact"+Num2Str(Channel) 


variable tt,rr,ll,pp,xx,yy,ff

// Get Snippet Duration, nLoops etc..
variable nTriggers
variable Ignore1stXTriggers = 0
variable IgnoreLastXTriggers = 0
variable last_data_time_allowed = InputTraceTimes[nF-1][0]-IgnoreLastXseconds


for (tt=0;tt<Dimsize(triggertimes,0);tt+=1)
	if (NumType(Triggertimes[tt])==0)
		if (Ignore1stXseconds>Triggertimes[tt])
			Ignore1stXTriggers+=1
		endif
		if (Triggertimes[tt]<=last_data_time_allowed)
			nTriggers+=1
		endif
	else
		break
	endif
endfor
if (Ignore1stXTriggers>0)
	print "ignoring first", Ignore1stXTriggers, "Triggers"
endif
variable SnippetDuration = Triggertimes[TriggerMode+Ignore1stXTriggers]-Triggertimes[0+Ignore1stXTriggers] // in seconds
variable nLoops = floor((nTriggers-Ignore1stXTriggers-IgnoreLastXTriggers) / TriggerMode)

variable Last_Snippet_Length = last_data_time_allowed - ((nLoops * SnippetDuration) + Triggertimes[Ignore1stXTriggers])  

print Last_Snippet_Length

if (Last_Snippet_Length<SnippetDuration)
	IgnoreLastXTriggers = TriggerMode
endif

print nTriggers, "Triggers, ignoring 1st",  Ignore1stXTriggers, "and last", IgnoreLastXTriggers, "and skipping in", TriggerMode, "gives", nLoops, "complete loops"
print "Note: Last", IgnoreLastXseconds, "s are also clipped"

// make line precision timestamped trace arrays
variable FrameDuration = nY*LineDuration // in seconds
variable nPoints = (nF * FrameDuration) / LineDuration
make /o/n=(nPoints,nRois) OutputTracesUpsampled = 0 // in line precision - deafult 500 Hz
make /o/n=(nPoints,nRois) OutputTimesUpsampled = 0 // Andre 2016 04 13
for (rr=0;rr<nRois;rr+=1)
// for linear interpolation
	make /o/n=(nF*nY) CurrentTrace = NaN
	make /o/n=(nF*nY) CurrentTime = NaN	// Andre addition 2016 04 13
	setscale x,InputTraceTimes[0][rr],InputTraceTimes[nF-1][rr],"s" CurrentTrace
	for (ff=0;ff<nF-1;ff+=1)
		for (yy=0;yy<nY; yy+=1)
			CurrentTrace[ff*nY+yy]=(InputTraces[ff+1][rr]*yy+InputTRaces[ff][rr]*(nY-yy))/nY
			CurrentTime[ff*nY+yy]=(InputTraceTimes[ff+1][rr]*yy+InputTraceTimes[ff][rr]*(nY-yy))/nY // andre addition 2016 04 13
		endfor
	endfor
	variable lineshift = round(InputTraceTimes[0][rr] / LineDuration)
	OutputTracesUpsampled[lineshift,nPoints-4*FrameDuration/LineDuration][rr] = CurrentTrace[p-lineshift] // ignores last 4 frames of original recording to avoid Array overrun
	OutputTimesUpsampled[lineshift,nPoints-4*FrameDuration/LineDuration][rr] = CurrentTime[p-lineshift] // andre additinon 2016 04 13
endfor

// Snipperting and Averaging

make /o/n=(SnippetDuration * 1/LineDuration,nLoops,nRois) OutputTraceSnippets = 0 // in line precision
make /o/n=(SnippetDuration * 1/LineDuration,nLoops,nRois) OutputTimeSnippets = 0 // Andre 2016 04 13
make /o/n=(SnippetDuration * 1/LineDuration,nRois) OutputTraceAverages = 0 // in line precision
make /o/n=(SnippetDuration * 1/LineDuration) OutputStimArtiAverage = 0

setscale /p x,0,LineDuration,"s" OutputTraceSnippets,OutputTraceAverages, OutputStimArtiAverage

for (rr=0;rr<nRois;rr+=1)
	for (ll=0;ll<nLoops;ll+=1)
		OutputTraceSnippets[][ll][rr]=OutputTracesUpsampled[p+Triggertimes[ll*TriggerMode+Ignore1stXTriggers]/LineDuration][rr]
		OutputTraceAverages[][rr]+=OutputTracesUpsampled[p+Triggertimes[ll*TriggerMode+Ignore1stXTriggers]/LineDuration][rr]/nLoops
		OutputTimeSnippets[][ll][rr] = OutputTimesUpsampled[p+Triggertimes[ll*TriggerMode+Ignore1stXTriggers]/LineDuration][rr]		// Andre 2016 04 13
	endfor
endfor
for (ll=0;ll<nLoops;ll+=1)
	OutputStimArtiAverage[]+=StimArtifact[p+Triggertimes[ll*TriggerMode+Ignore1stXTriggers]/LineDuration][0]/nLoops
endfor

// Calculate Quality criterion:

make /o/n=(nRois) QualityCriterion = NaN // (1 - variance of mean / mean of variance)
make /o/n=(nRois) MoV = NaN // (1 - variance of mean / mean of variance)
make /o/n=(nRois) VoM = NaN // (1 - variance of mean / mean of variance)

for (rr=0;rr<nRois;rr+=1)
	make /o/n=(SnippetDuration * 1/LineDuration) currentwave = OutputTraceAverages[p][rr]
	Wavestats/Q currentwave
	variable variance_of_mean = V_SDev^2
	VoM[rr]=variance_of_mean
	variable mean_of_variance = 0
	make /o/n=(nLoops) currentwave2 = naN
	for (ll=0;ll<nLoops;ll+=1)
		make /o/n=(SnippetDuration * 1/LineDuration) currentwave = OutputTraceSnippets[p][ll][rr]//-OutputTraceAverages[p][rr]
		Wavestats/Q currentwave
		currentwave2[ll]=V_SDev^2
	endfor
	Wavestats/Q currentwave2
	mean_of_variance=V_Avg
	MoV[rr]=mean_of_variance
	QualityCriterion[rr]= variance_of_mean / Mean_of_variance
endfor

// make average stack (optional) - frame precision

if (AverageStack_make==1)
	print "Generating AverageStack"
	make /o/n=(nX-X_Cut,nY) OutputStack_avg = 0
	make /o/n=(nX-X_Cut,nY,SnippetDuration/FrameDuration) OutputStack = 0 // at framerate
	for (ll=0;ll<nLoops;ll+=1)	// aveage across loops
		variable CurrentTriggerFrame = (Triggertimes[ll*TriggerMode+Ignore1stXTriggers])/FrameDuration
		for (xx=0;xx<nX-X_Cut;xx+=1)
			for (yy=0;yy<nY;yy+=1)
				Multithread OutputStack[xx][yy][]+=InputStack[xx+X_Cut][yy][r+CurrentTriggerFrame]
			endfor
		endfor
	endfor
	OutputStack[][][]/=nLoops
	// Convert to 8 bit & flip Y axis (as imageJ is default Y flipped relative to Igor)
	make /o/n=(nX-X_Cut,nY,SnippetDuration/FrameDuration) AverageStack_8bit = OutputStack[p][nY-1-q][r]

	// get brightness histogram
	Make/N=(2^16) /O Brightness_Hist = 0
	Make/N=(2^16) /O currentwave_Hist = 0
	make /o/n=(SnippetDuration/FrameDuration) currentwave = 0
	for (xx=0;xx<nX-X_cut;xx+=1)
		for (yy=0;yy<nY;yy+=1)
			Multithread currentwave = AverageStack_8bit[xx][yy][p]
			Histogram/B={0,1,2^16} currentwave,currentwave_Hist
			Multithread Brightness_Hist[]+=currentwave_Hist[p]
		endfor
	endfor
	WaveStats/Q Brightness_Hist
	Brightness_Hist/=V_Max
	
		
	// find start of brightness distribution
	variable Min_brightness = 0
	for (pp=0; pp<2^16;pp+=1)
		if (Brightness_Hist[pp]>brightness_cutoff)
			Min_brightness = pp
			pp = 2^16 // abort
		endif
	endfor
	// find end of brightness distribution
	variable Max_brightness = Min_brightness
	for (pp=Min_brightness; pp<2^16;pp+=1)
		if (Brightness_Hist[pp]<brightness_cutoff)
			Max_brightness = pp
			pp = 2^16 // abort
		endif
	endfor
	print "Setting brightness between", Min_brightness, "and", Max_brightness, "for Average Stack 8 bit"
		
	// scaling outputwave
	//AverageStack_8bit[][][]=(AverageStack_8bit[p][q][r]<Min_brightness)?(Min_brightness):(AverageStack_8bit[p][q][r])
	//AverageStack_8bit[][][]=(AverageStack_8bit[p][q][r]>Max_brightness)?(Max_brightness):(AverageStack_8bit[p][q][r])
	
	//AverageStack_8bit[][][]-=Min_brightness
	//AverageStack_8bit[][][]/=(Max_brightness-Min_brightness) / (2^8)	

	duplicate /o OutputStack $output_name3 // within Igor it keeps the non flipped 32 bit one
	imagesave /s/t="tiff" AverageStack_8bit // for export it spits out the flipped one at 8 bit

endif

// export handling
duplicate /o OutputTraceSnippets $output_name1
duplicate /o OutputTraceAverages $output_name2
duplicate /o OutputTimeSnippets $output_name4
duplicate /o OutputStimArtiAverage $output_name5

	
// display

if (Display_averages==1)
	display /k=1
	make /o/n=(1) M_Colors
	Colortab2Wave Rainbow256
	
	Appendtograph /l=StimY $output_name5
	ModifyGraph fSize=8,noLabel(StimY)=2,axThick(StimY)=0,lblPos(StimY)=47;DelayUpdate
	ModifyGraph axisEnab(StimY)={0.05,0.15},freePos(StimY)={0,kwFraction}
	ModifyGraph rgb($output_name5)=(0,0,0)
	
	for (rr=0;rr<nRois;rr+=1)
		string YAxisName = "YAxis_Roi"+Num2Str(rr)
		string tracename
		for (ll=0;ll<nLoops;ll+=1)
			tracename = output_name1+"#"+Num2Str(rr*nLoops+ll)
			if (ll==0 && rr==0)
				tracename = output_name1
			endif
			Appendtograph /l=$YAxisName $output_name1[][ll][rr]
			ModifyGraph rgb($tracename)=(52224,52224,52224)
		endfor	
		tracename = output_name2+"#"+Num2Str(rr)
		if (rr==0)
			tracename = output_name2
		endif
		Appendtograph /l=$YAxisName $output_name2[][rr]
		variable colorposition = 255 * (rr+1)/nRois
		ModifyGraph rgb($tracename)=(M_Colors[colorposition][0],M_Colors[colorposition][1],M_Colors[colorposition][2])
		ModifyGraph lsize($tracename)=1.5
		
		variable plotfrom = (1-((rr+1)/nRois))*0.8+0.2
		variable plotto = (1-(rr/nRois))*0.8+0.2
		
		ModifyGraph fSize($YAxisName)=8,axisEnab($YAxisName)={plotfrom,plotto};DelayUpdate
		ModifyGraph freePos($YAxisName)={0,kwFraction};DelayUpdate
		Label $YAxisName "\\Z10"+Num2Str(rr)
		ModifyGraph noLabel($YAxisName)=1,axThick($YAxisName)=0;DelayUpdate
		ModifyGraph lblRot($YAxisName)=-90
	endfor
	ModifyGraph fSize(bottom)=8,axisEnab(bottom)={0.05,1};DelayUpdate
	Label bottom "\\Z10Time (\U)"
endif


// cleanup
killwaves InputTraces, InputTraceTimes,CurrentTrace,OutputTracesUpsampled,OutputTraceSnippets,OutputTraceAverages,OutputStack,OutputStack_avg
killwaves OutputStimArtiAverage, currentwave2 // AverageStack_8bit, currentwave, currentwave_Hist
//killwaves OutputStackUpsampled

end